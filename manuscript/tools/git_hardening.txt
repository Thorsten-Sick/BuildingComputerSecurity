# GIT hardening {#chapter-git}

The GIT ecosystem grew and GIT is one of the most used VCS nowadays. GIT itself does offer some features you can use to increase the security of the build process. Internet hosting services for code (like Github and Gitlab) offer additional CI/CD features to simplify the development process and - at the same time - improve code quality and security.

## Pure Git

Git allows to write *hooks* on certain events. Hooks are simple scripts in a special folder that execute when this event occurs. These can be *pre-commit*, *post-checkout* or similar. There are two style of hooks:

**Local hooks** are client side and the developer maintains them to simplify their workflow.

**Server-side hooks** run on the server - right before the push happens - and this way **enforce** a policy.

When setting up a team process it is smart to search the web for "git-hooks" and use it to improve everyone's workflow (local hooks) and centrally enforce policy (server-side hooks).

This way security relevant things can be cared for ("does it compile without warnings ?" would be the simplest one).

Other things to enforce:

* Coding style
* Good (long) commit messages with links to issues
* Added unit tests covering the new code

This has big benefits on:

* code quality
* enforces best practice even in dire situations
    * gives the developers an explanation towards management ("This will take one more hour, gotta do this right or it will not be checked in")
* lift team spirit, because **THE MACHINE** enforces the coding style, not this other developer who is a grumpy guy and prevents anything creative

Other problems this will prevent are VCS specific issues like "Do no commit credentials and secrets" by using credential scanners.



%% ## Security alerts
%%https://blog.github.com/2018-07-12-security-vulnerability-alerts-for-python/
%%https://github.com/srcclr/commit-watcher


%% Adding empty git folder: put .gitkeep file into the folder

%% Git GUIs:
%% * Git Cola (Python)
%% * GitG
%% * Gitqlient
%% * Relagit
%% * Gitnuro

%% Bash prompt: https://github.com/magicmonty/bash-git-prompt


%% TODO: GPG keys to GIT


%% SECURITY.md file:
%% - disclosure policy
%% - bug bounty ?
%% security@ address

%% Two factor authentication

%% Open Source testing: SonarCloud, CodeClimate, Snyk

%% TODO: Gerrit, collaborative code review tool for git

## Github

Github offers so called *actions* to create your own workflow for your project. Those actions can contain almost any tool that you read about in this book so far. For example: Static Code analysis. On certain stages in your coding workflow you can trigger those actions. Good stages can be:

* When someone starts a Pull Request (PR)
* When code gets merged into your master branch
* Before debug/release build

That way you can enforce a minimum code quality. Or run the unit tests before anyone has to review the code of the PR manually.

The configuration is stored in *yaml* files in the folder *.github/workflow*

Interesting for Pull Requests (PR) will be to **test only the changed files**. The trick to extract these look like:

{lang="bash"}
    - name: List changed files, check for string "do not release" as a test
      run: |
        URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/pulls/${{ github.event.pull_request.number }}/files"
        FILES=$(curl -s -X GET -G $URL | jq -r '.[] | .filename')
        ! fgrep "do not release" -q $FILES
        # Check if the text "do not release" is in a PR file. Fail the PR if it is.

## Getting it done

Sit down with your team, find a workflow to extend code quality, improve security and reduce manual work for Pull Requests.
Later extend that to other stations of the life cycle of your projects. Like checking the main branch of your VCS on a daily basis. Or check before moving the code to production.