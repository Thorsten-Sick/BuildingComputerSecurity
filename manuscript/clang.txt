# CLANG

Clang is a compiler in the same league as GCC. It has some different features.
As you will either use one or the other in your project it gets an own chapter.

https://clang-analyzer.llvm.org/

It is a separate Clang Project and has a command line tool described here: https://clang-analyzer.llvm.org/scan-build.html

It will use the project's Makefile to build the project and analyse it.

Available directly in the compiler:

* Security warnings: -Wformat -Wformat-security -Werror=format-security

## Static analysis

https://clang-analyzer.llvm.org/

sudo apt install clang clang-tools

sudo ln -s /usr/bin/llvm-symbolizer-6.0 /usr/bin/llvm-symbolizer   # Needed if several symbolizers are installed

scan-build <C-Compiler and it's settings>

## Dynamic analysis

https://clang.llvm.org/docs/AddressSanitizer.html
https://clang.llvm.org/docs/MemorySanitizer.html
https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html
https://clang.llvm.org/docs/LeakSanitizer.html
https://clang.llvm.org/docs/SanitizerCoverage.html

#### CLANG

* -D_FORTIFY_SOURCE=2 (as with GCC)
* ASLR for binaries: -fPIE -pie
* ASLR for libraries: -fPIC
* Stack protector:
    * -fstack-protector is basic
    * -fstack-protector-strong adds more functions
    * -fstack-protector-all adds all functions and is more expensive
* -fsanitize=safe-stack adds a second stack for re turn addresses and other valuable data
* Control flow integrity checks: -fsanitize=cfi -fuse-ld=gold -flto (http://clang.llvm.org/docs/ControlFlowIntegrity.html )
* Read only memory sections in ELF: -Wl,-z,relro
* Resolve all dynamic symbols during program load:  -Wl,-z,now


See more Clang: https://blog.quarkslab.com/clang-hardening-cheat-sheet.html
s


## Dynamic code analysis

Important: You can run programs compiled with tools like ASAN compiled in. But you
should not ship them that way. ASAN and similar are for finding bugs. They will not
harden your code and can introduce new vulnerbilities.

Best use case: If you have a fully automated and large test set run that
against your ASAN compiled program.
Be aware that many of those dynamic code analysis tools will come with a
slowdown like 2x-15x....and factor 2 to 10 increased memory usage.


## CLANG

%% .. TODO: Experiment with it

%% https://blog.quarkslab.com/clang-hardening-cheat-sheet.html

## ASAN (Address Sanitizer)

Detects memory errors (out-of-bounds access, user-after-free, ...)

https://clang.llvm.org/docs/AddressSanitizer.html

Compile with -fsanitize=address . Some more options to that are available (see homepage).

## LSAN (Leak Sanitizer)

Included in ASAN. Detects memory leaks with minor overhead.
See: https://clang.llvm.org/docs/LeakSanitizer.html

## UBSan (Undefined Behaviour Sanitizer)

Detects bugs like using NULL pointers, signed integer overflows, ...

See: https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html

## Memory Sanitizer

Detects uninitialized reads.

See: https://clang.llvm.org/docs/MemorySanitizer.html

## Thread Sanitizer

Detects data races.

See: https://clang.llvm.org/docs/ThreadSanitizer.html

## Code coverage
(Clang)

https://clang.llvm.org/docs/SourceBasedCodeCoverage.html
https://clang.llvm.org/docs/SanitizerCoverage.html
gcov - A GCC-compatible coverage implementation which operates on DebugInfo. This is enabled by -ftest-coverage or --coverage.
