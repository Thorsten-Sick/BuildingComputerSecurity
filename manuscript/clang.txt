# CLANG {#chapter-clang}

C> Thorsten Sick

A compiler can assist you in creating secure software. There are several major
features you can expect from it:

* Warnings
* More in-depth static code analysis (while compiling)
* Dynamic code analysis (create a specific runtime that does analyse the code)
* Code coverage: Which parts of the code are run and tested ?
* Fuzzing

[Clang](https://clang.llvm.org/) is a compiler in the same league as GCC. It is the C-frontend for LLVM.
Basic command lines are very similar, but it has some different features -
especially for code verification.

https://clang-analyzer.llvm.org/

It is a separate Clang Project and has a command line tool described here: https://clang-analyzer.llvm.org/scan-build.html

It will use the project's Makefile to build the project and analyse it.

Available directly in the compiler:

* Security warnings: -Wformat -Wformat-security -Werror=format-security

## Static analysis

https://clang-analyzer.llvm.org/

{lang="bash"}
    sudo apt install clang clang-tools
    sudo ln -s /usr/bin/llvm-symbolizer-6.0 /usr/bin/llvm-symbolizer   # Needed if several symbolizers are installed
    scan-build <C-Compiler and it's settings>

## Dynamic analysis

https://clang.llvm.org/docs/AddressSanitizer.html
https://clang.llvm.org/docs/MemorySanitizer.html
https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html
https://clang.llvm.org/docs/LeakSanitizer.html
https://clang.llvm.org/docs/SanitizerCoverage.html

#### CLANG

* -D_FORTIFY_SOURCE=2 (as with GCC)
* ASLR for binaries: -fPIE -pie
* ASLR for libraries: -fPIC
* Stack protector:
    * -fstack-protector is basic
    * -fstack-protector-strong adds more functions
    * -fstack-protector-all adds all functions and is more expensive
* -fsanitize=safe-stack adds a second stack for re turn addresses and other valuable data
* Control flow integrity checks: -fsanitize=cfi -fuse-ld=gold -flto (http://clang.llvm.org/docs/ControlFlowIntegrity.html )
* Read only memory sections in ELF: -Wl,-z,relro
* Resolve all dynamic symbols during program load:  -Wl,-z,now


See more Clang: https://blog.quarkslab.com/clang-hardening-cheat-sheet.html
s


## Dynamic code analysis

Important: You can run programs compiled with tools like ASAN compiled in. But you
should not ship them that way. ASAN and similar are for finding bugs. They will not
harden your code and can introduce new vulnerbilities.

Best use case: If you have a fully automated and large test set run that
against your ASAN compiled program.
Be aware that many of those dynamic code analysis tools will come with a
slowdown like 2x-15x....and factor 2 to 10 increased memory usage.


## CLANG

%% .. TODO: Experiment with it

%% https://blog.quarkslab.com/clang-hardening-cheat-sheet.html

## ASAN (Address Sanitizer)

Detects memory errors (out-of-bounds access, user-after-free, ...)

https://clang.llvm.org/docs/AddressSanitizer.html

Compile with -fsanitize=address . Some more options to that are available (see homepage).

## LSAN (Leak Sanitizer)

Included in ASAN. Detects memory leaks with minor overhead.
See: https://clang.llvm.org/docs/LeakSanitizer.html

## UBSan (Undefined Behaviour Sanitizer)

Detects bugs like using NULL pointers, signed integer overflows, ...

See: https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html

## Memory Sanitizer

Detects uninitialized reads.

See: https://clang.llvm.org/docs/MemorySanitizer.html

## Thread Sanitizer

Detects data races.

See: https://clang.llvm.org/docs/ThreadSanitizer.html

## Code coverage
(Clang)

https://clang.llvm.org/docs/SourceBasedCodeCoverage.html
https://clang.llvm.org/docs/SanitizerCoverage.html
gcov - A GCC-compatible coverage implementation which operates on DebugInfo. This is enabled by -ftest-coverage or --coverage.

## Fuzzing

Clang is a part of the fuzzing tools **AFL** and **libFuzzer**. For more details read the [fuzzing chapter](#chapter-fuzzing).
