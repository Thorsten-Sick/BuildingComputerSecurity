# Testing compiled binaries {#chapter-testing-compiling}

C> By: Thorsten Sick

C> For: Developers, Tester

As many mitigation features are kind of invisible you will needs tools
to test the compiled binary before you release it.

You want to automatically test:

* Is this a beta release or the real one ?
* Is it a debug release ? (with or without debug symbols)
* Is ASLR on ?
* Are there additional dependencies ?
    * linked libs ?
    * attached info (see there)

Having prepared a set of tools for manual verification plus a automatic test
at least before the binaries are shipped is very smart.

## Linux

On Linux, a tool to verify the hardening settings is *hardening-check* which can
be found here:

[Hardening-check](https://github.com/ProhtMeyhet/hardening-check)

It will check for:

* PIE (ASLR)
* Stack protection
* Fortified source
* Read-only relocations (relro)
* Immediate binding

You can do many of these verifications using built-in tools.

Testing specifically for **immediate binding** manually:

{lang="bash"}
    readelf -d program | grep BIND

On a secure program you will get something like:

{lang="bash"}
    0x000000000000001e (FLAGS)              BIND_NOW

Insecure programs will return nothing.

If you do not get the BIND_NOW (which would indicate *full relro*)
you can still check for *partial relro*:

{lang = "bash"}
    objdump -x program|grep RELRO


Checking for **forgotten debug symbols** in a secure program:

{lang="bash"}
    >objdump --syms program

    program:     file format elf64-x86-64

    SYMBOL TABLE:
    no symbols

If you see anything else (especially a list of symbols) you forgot them in
the binary. Remove them by calling the command line tool *strip*.

%% Also relevant for "elf_format.wip": [ELF format](https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/)

%% Todo: ldd and lddtree

%% TODO: apt install pax-utils; scanelf

## Windows

Check for ASLR, DEP, SafeSEH, ... in Windows binaries

[PESecurity](https://github.com/NetSPI/PESecurity)

%% TODO: Make table
%%[Gunstone example for python](https://richardgunstone.net/2018/08/02/analysing-pe-executables-and-their-aslr-dep-seg-and-cfg-security-flags/)
%% PEFILE:
%% IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA 0x0020  use 64 bit space for ASLR LINKER/EDITBIN: /HIGHENTROPYVA
%% IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040 Use ASLR          LINKER/EDITBIN: /DYNAMICBASE
%% IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY 0x0080 Signature check on startup LINKER/EDITBIN: /INTEGRITYCHECK
%% IMAGE_DLLCHARACTERISTICS_NX_COMPAT 0x0100 Executable is compatible with DEP LINKER/EDITBIN: /NXCOMPAT
%% IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 0x0200 If set will not look for manifest file LINKER/EDITBIN: /ALLOWISOLATION:NO
%% IMAGE_DLLCHARACTERISTICS_NO_SEH 0x0400 Create a table of safe exeception handlers in the binary LINKER /SAFESEH:NO
%% IMAGE_DLLCHARACTERISTICS_NO_BIND 0x0800 Signed files should not be bound, invalidates signature. LINKER/EDITBIN: /ALLOWBIND:NO
%% IMAGE_DLLCHARACTERISTICS_APPCONTAINER 0x1000 Run only in process isolation LINKER/EDITBIN: /APPCONTAINER
%% IMAGE_DLLCHARACTERISTICS_GUARD_CF 0x4000 (Control Flow Guard) Check call targets during runtime. COMPILER/LINKER: /GUARD

%% python
{lang="python"}
    import pefile
    pe = pefile.PE("test.exe")
    features = [('IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA', 0x0020),
                ('IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE', 0x0040),
                ('IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY', 0x0080),
                ('IMAGE_DLLCHARACTERISTICS_NX_COMPAT', 0x0100),
                ('IMAGE_DLLCHARACTERISTICS_NO_ISOLATION', 0x0200),
                ('IMAGE_DLLCHARACTERISTICS_NO_SEH', 0x0400),
                ('IMAGE_DLLCHARACTERISTICS_NO_BIND', 0x0800),
                ('IMAGE_DLLCHARACTERISTICS_APPCONTAINER', 0x1000),
                ('IMAGE_DLLCHARACTERISTICS_GUARD_CF', 0x4000),
                ]
    for s, h in features:
        print("{}: {}".format(s, bool(pe.OPTIONAL_HEADER.DllCharacteristics & h)))

*I had no time so far to test this tool. I will update this paragraph as soon as I did. I am still leaving it here because it is very valuable even as unverified information*

%% .. TODO: Test

%% TODO [CheckSec](https://github.com/slimm609/checksec.sh)

%% TODO: [Searching statically-linked vulnerable library functions in executable code](https://googleprojectzero.blogspot.com/2018/12/searching-statically-linked-vulnerable.html)

## Attached info

It is possible to attach an info blob (like xml) to a PE and ELF file.
Directly after you compiled the binary, your build tool could create that info blob
and your release system could later verify it - to be sure to release the
intended version of the file. It can contain things like a "beta" flag -
to avoid accidentally release a beta on the stable update channel and
version numbers - to ensure to release the proper version. Or it could be a
list of dependencies (modules and their version) to other components you offer.

Of course this can also be achieved by registering the binary in your file
database by sha256 and putting the flags in there.
