# Secret scanning {#chapter-secret-scanning}

## Do not commit credentials and secrets

Credentials carry permissions and privileges. Like "signing a file" and "access to a server". You do not want those in a Git repository. Even if it is a private one. Sooner or later you will invite other people to contribute. And then those credentials are either forgotten and there as files or in the git history.
Secrets must never be pushed into a code repository. They should be stored in special secret stores.

Secrets are 

* passwords
* private keys
* API keys
* tokens

By accident they can end up hardcoded ("it was the simplest way") or in configuration files. Besides having no proper restriction on who can access these tokens (and they will even remain in the GIT history after deleting them...) this also means hard coded secrets.

To identify those secrets you should use secret scanners. They are especially valuable in pre-commit hooks to prevent uploading. And in the PR automation on your Git workflow to trigger a security incident and rotate your secrets (yes, uploading secrets is this bad).

## Secret scanners

To prevent committing credentials there are special scanners. They look for file names or patterns in the source code that look like a private ssh key or something similar. Some also support entropy scanning.

There are three scenarios where those scanners are used.

### The opportunistic scanner

An attacker scans a wide range of GIT repos to find credentials

* [GitGot](https://github.com/BishopFox/GitGot) For all kinds of data
* [GitMiner](https://github.com/UnkL4b/GitMiner) More focused on credentials

As developer or engineer you should know those exist. But you will not use them.

### The investigative scanner

Find credentials in a 1-2 hour session in your code. This is for manual use.

[DumpsterDiver](https://github.com/securing/DumpsterDiver) uses creative entropy based password detection. Normal mixed case variables with numbers can still trigger this detection and cause False Positives. This is OK if you invest the time to review them. A fallback to regex search is possible.

It also supports search patterns and configuration files. This is a great way for a first manual overview.

Make sure to use the parameter *-a* which adds the rules.yaml regexes. The default file is small. Enhance it with your own rules.

For a larger project you will get lots of reports. Many will be FPs. But for this kind of scan you want something aggressive.

### Security gate scanner

Scans for exact patterns. This scanner has low FPs but will also not detect many unexpected accidents. This can be used as a automated security gate at a local GIT hook or when checking PR in the build chain.

* [Git-secrets](https://github.com/awslabs/git-secrets) is AWS and GIT integrated, supports egrep regex patterns, can ignore FPs
* [SecretScanner](https://github.com/deepfence/SecretScanner) Container and filesystem scanner. Extending can be done in config.yaml. It supports file name and content scanning (regexes). For plain source paths this is a good pick.
* [Gitleaks](https://github.com/zricethezav/gitleaks) Scans files and GIT. Rules can be extended using Golang regex. An allowlist is also there. Sarif output is possible. Important: The scanned source must be in a GIT repo - if your source is in a GIT you should consider this tool. It will also find old commits.
* [Trufflehog](https://github.com/trufflesecurity/trufflehog) Can scan many things including Github repos and files. This scanner also verifies secrets by trying to use them. A low FP rate can be expected. But you need access to those services ! This is why it is strong on API tokens, but hard to use with passwords to own services. New detection rules are written in Go.

## Secret stores

The solution to your problem is to avoid default secrets (maybe force the user to pick new ones, or create them on first use). Also store them in "Secret stores". Clouds like AWS, Google Cloud and Azure have them. The libraries to access those online stores can also store them in local encrypted files.

Golang's [Secrets](https://gocloud.dev/howto/secrets/) is an example.

%% TODO: https://github.com/michenriksen/gitrob  is deprecated ?



%% Uses gitrob rules:
%% For example: [Repo security scanner](https://github.com/techjacker/repo-security-scanner) scans for

%% * Different private keys
%% * Different command histories
%% * Configuration files
%% * Password files
%% * pcaps and other dumps

%% It is using:

%% * Filename
%% * Path
%% * File extension

%% to identify critical content.