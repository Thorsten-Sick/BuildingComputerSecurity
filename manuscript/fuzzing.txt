# Fuzzing {#chapter-fuzzing}

Fuzzing is inserting random data into the system with the goal to cause invalid
states. This can be crashing, memory leaks, endless loops, ...

Once set up fuzzing tools run full-auto for nights and collect crash logs.

Data can be send to any kind of input:

* Command line
* File
* Network data
* Images (camera)
* Audio
* UART/...
* UI (testing buttons, edit boxes, ...)
* System messages (MQTT, DBUS, ...)
* Shared memory
* Environment variables
* WiFi and Bluetooth
* at the library API (libfuzzer)

If you ship software that includes 3rd party libraries or programs, you should
fuzz those as well. You ship it to customers - you are responsible.

An important step in fuzzing is to keep the relevant input data for the
debugging session later. This can be done by keeping the files. Some fuzzers
have a predictable algorithm that generates the same permutations for a given seed.
For those keep the seed in a database and re-create the input data before debugging.

There are several fuzzers, from simple random data generators to coverage
based like libfuzzer and AFL.
All of them have advantages and disadvantages.

You can start with a simple variant if your program has not been hardened yet
and while patching the bugs you find improve the fuzzer.

## Audience

Developers, Testers

## Training project

There is a practice target for fuzzing: [Fuzzgoat](#reference-fuzzgoat).
As there are many kinds of fuzzers and you maybe want to experiment with them
before getting started with your project.

## Fuzzing hardware

You can fuzz embedded devices. In addition to be able to send the broken data
to the device (UART, BLE, ...) you also need a way to evaluate the system health.
Anything that works like a ping (like: request version information over WiFi)
is already quite good.
Another thing is: You want to be able to reset the device. LAN controlled
power sockets are a way. Or toggling the reset button using a micro controller.

## DIY fuzzer

It is quite simple to write own fuzzers. The tools later in this chapter will
be much more powerful, but with some tricks the core concept of fuzzers is simple:

* Create data that has a *almost* valid structure. You want it to be processed code deeper in the victim's project
* For the same reason: Create *valid checksums* for your fake data
* An alternative is to de-activate the checksum-validation code while fuzzing the application
* Let it run for hours, maybe days
* Detect if you break the victim:
    * crashes,
    * buffer overflows (AddressSanitizer)
    * loops, hangs, ... (ThreadSanitizer)
    * memory leaks (LeakSanitizer)

%% TODO: Valgrind is also an option to detect buggy behaviour

* As soon as you break the victim: Store the responsible data chunk away for the debugging session

To improve the fuzzing results, sprinkle the victim code with *assertions* to
provoke crashes on invalid states.

Fuzzers can be simple, see the next example:

Simple DNS fuzzer (from: https://github.com/sgayou/medfusion-4000-research/blob/master/doc/README.md)

{lang="python"}
    import socket
    import os

    UDP_IP = "192.168.100.151"
    UDP_PORT = 53

    sock = socket.socket(socket.AF_INET,
                     socket.SOCK_DGRAM)
                     sock.bind((UDP_IP, UDP_PORT))

    while True:
        data, addr = sock.recvfrom(1024)
        packet = str(data[0]) + str(data[1]) + b"\x81\x80" + os.urandom(128)
        sock.sendto(packet, addr)

## Radamsa

https://gitlab.com/akihe/radamsa

A simple way to detect crashed programs in bash scripts is to check the exit value.

Taking an example from Radamsa (check out the link, there are more examples).

{lang="bash"}
    while true
     do
       # Generate test-sample files
       # call program with sample files
       test $? -gt 127 && break
     done



## AFL American fuzzy lop

Uses compile-time instrumentation and a genetic algorithm to discover new
test cases.

Pro:
    * It is fast
    * It is exhaustive

Con:
    * It needs instrumented binaries - you have to re-compile them

{lang="bash"}
    apt install AFL

To use AFL the program must be compiled with a special AFL compiler.
AFL is available for clang (afl-clang) and gcc (afl-gcc).

After compiling you call it with *afl-fuzz*.

A good example is the *fuzzgoat* project which has a vulnerable program and a
Makefile to show how AFL is compiled into it and then executed.

The home page of AFL: http://lcamtuf.coredump.cx/afl/

Some technical overview:
https://tunnelshade.in/blog/2018/01/afl-internals-compile-time-instrumentation/

The best resource so far is the README:

*/usr/share/doc/afl-doc/docs/README*

## libFuzzer

The most effective way if you have access to the API and code. It is part of Clang 6.0+.
You may notice: Ubuntu 17.10 at least does not have this Clang installed yet. So you will
want to install a Clang 6.0 from a PPA.

https://llvm.org/docs/LibFuzzer.html

LibFuzzer supports a Corpus for Input and Output samples to test with. This improves speed a lot.

%% .. TODO: more libFuzzer

## More fuzzing tricks

* Parallelize fuzzing
    * Google's ClusterFuzz is an example: https://github.com/google/oss-fuzz/blob/master/docs/clusterfuzz.md
* Do it on Linux. It has more powerful monitoring tools for dynamic code analysis
* Fix found bugs ASAP, so your fuzzer can dig deeper
    * There are smart fuzzers that can cluster the crashes by the bugs they very likely belong to



%% TODO run under Valgrind or strace or gdb
