# Bluetooth LE {#chapter-btle}

C> Thorsten Sick

## Basics

Bluetooth LE (low energy) is a special mode of modern bluetooth devices. It
behaves very differently fro normal bluetooth behaviour with the benefit of
significantly lower power consumption.

It does not maintain a longer connection (like used by classical bluetooth
and streaming audio) but uses small data bursts to exchange data snippets.

Those data snippets are basically key-value pairs.

A key is called a "characteristic". Several characteristics can be combined
into a service. A device can have several services. For example one handling
all the device specific data (brand, model, version) while another is sharing
measurements (temperature, air pressure, ...)

There are also "profiles" which are standardized services/characteristics for
a ble device. The "Heart Rate monitor" profile for example allows any heart
rate monitor device to be compatible with a range of apps.

A good way to get started is [Adafruit BLE](https://learn.adafruit.com/introduction-to-bluetooth-low-energy/introduction)

I am using Kali linux for many of my tests/attacks on my devices. Sometimes it
can be hard to find a bluetooth device that is working correctly
(my built-in bluetooth adapter of my laptop fails). So search your drawers for
a working device. In my case it is a LogiLink BT USB adapter BT0037. YMMV.

## BLE Security

BLE securit is weaker than the Bluetooth classic security. Limiting factor is
the pairing of devices. It requires a pin number to be entered - but with small
and cheap devices without no human interaction (keypad, display) this is hard
to achieve.

* Just Works
* Numeric Comparison (Only for LE Secure Connections)
* Passkey Entry
* Out of Band (OOB)

Where the first three options have drawbacks: either an all 0 key (just works)
or short keys (all the others). The thing to go for is OOB: The pairing is
done over an other channel - not over the air. This can be NFC or QR codes or
an attached wire. Secure but not an option for many device classes.

The [bluetooth standard](https://blog.bluetooth.com/bluetooth-pairing-part-4) has more details.

Also: With Bluetooth 4.2 Elliptic Curve Diffie Hellman (ECDH) is introduced.
Try to be compatible with this version or better !

%% TODO Experiment: Can we exchange keys using bluetoothctl ?
%% [](https://github.com/IanHarvey/bluepy/issues/227)

%% Maybe bluepy gets a OOB feature: https://github.com/IanHarvey/bluepy/issues/300   (not existing yet !)

## Nordic Semiconductor: nRF Connect

The simplest tool to support you in testing a ble device you are developing is
an Android tool by Nordic Semiconductor. As you can not see radio frequencies
you have to fall back to this. Just install **nRF Connect** and scan for
devices. Connect to them, list their Services and Characteristics.

For automatic testing you will later want some other things. Just continue
reading.

## Basic OS tools

Linux has many command line tools to interact with bluetooth and bluetooth le.

Basically treat a ble device like any network device.

Activate a ble device:

{lang="bash"}
    hciconfig hci0 up

Scan for le devices:

{lang="bash"}
    hcitool lescan

Create a le connection:

{lang="bash"}
    hcitool lecc <address>

Delete a le connection:

{lang="bash"}
    hcitool ledc <handle>

Get some info like manufacturer:

{lang="bash"}
    hcitool leinfo <handle>


**gatttool** for Bluetooth LE::

%% {lang="bash"}
%%     gatttool -i <interface> -b <device address> -I
%%    > connect

%% TODO: Experiment with it !

%% to connect to a found device


## Bleah - Bluetooth LE hacking

A tool for bluetooth le hacking - and testing - is [bleah](https://github.com/evilsocket/bleah).
It can enumerate devices, list their services, list the characteristics and
write to them. This is very handy when developing Bluetooth LE enabled devices.

By [Evilsocket](https://www.evilsocket.net/)

Some examples for the command line of bleah:

Enumerate services and characteristics on a specific device

{lang="bash"}
    sudo bleah -i 1 -e -b 30:30:30:aa:aa:aa

* -i interface id. 1 is hci1
* -e enumerate
* -b <MAC> mac address of target

Set a specific value

{lang="bash"}
    sudo bleah -i 1 -b 30:30:30:aa:aa:aa -n 0x39 -d "100"

* -i interface id. 1 is hci1
* -n handle of characteristics
* -d value to set
* -b <MAC> mac address of target

Always going through bleah can be a bit slow (especially when doing fuzzing).
Gatttool can be an alternative for writing:

{lang="bash"}
    gatttool -b 30:ae:a4:1c:0c:26 --char-write-req -a 0x0039 -n $(echo -n "200"|xxd -ps)

Or reading:

{lang="bash"}
    gatttool -b 30:ae:a4:1c:0c:26 --char-read -a 0x0039

Gatttool handles values as hex, not string. Here bleah is more convenient.

Bleah is based on bluepy.

## Bluepy - python library for Bluetooth le

[Bluepy](https://github.com/IanHarvey/bluepy) is the library to use for
Bluetooth LE programming.

Thanks to a good [documentation](https://ianharvey.github.io/bluepy-doc/) it
is simple to write short python scripts to interact with your device.

## BlueZ

BlueZ is the linux kernel part (and user space tools) for Bluetooth.
Bluepy sits on top of BlueZ

## Adafruit Bluetooth LE sniffer

So far we have been checking the higher OSI layers. If you want to go down to
single packets there are two affordable options: "Adafruit Bluefruit LE Sniffer"
and the "Ubertooth".

Experimenting with the Adafruit I got challenged by some glitches
(maybe my fault, maybe the tools are better tested with the Ubertooth).

Adafruit Bluefruit LE Sniffer - Bluetooth Low Energy (BLE 4.0) - nRF51822 - v3.0
[Adafruit BLE sniffer](https://www.adafruit.com/product/2269)

[Adafruit BLE sniffer documentation](https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-sniffer)

Call it with::

{lang="bash"}
  python sniffer.py  /dev/ttyUSB0

After selecting a device it will log the BTLE messages for this device
connection into a pcap file.

To view it properly with wireshark, define the DLT_USER id to be "btle":
Preferences->Protocols->DLT_USER, set ID as "btle"

%% .. TODO: Research: Monitor connection when sending commands.

%% Wireshark does not recognize DLT_USER
%% [Ubertooth DLT fix](https://github.com/greatscottgadgets/ubertooth/issues/61)
%% go to Preferences->Protocols->DLT_USER and enter "btle" as protocol
that should help

%% [Convert PCAP](https://github.com/mikeryan/crackle/issues/26)

%% .. TODO: Fill tools



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


## Python programming

%% GATT [](https://github.com/peplin/pygatt)
%% Fallback [](https://github.com/getsenic/gatt-python)


## Potential attacks

List of potential attacks for threat modelling:

* Jamming (smart by blocking channels or sending crafted packets, stupid by noise)
* Inpersonating (cloning) of a device
* Passive sniffing (if there is no link layer encryption)
* For encrypted layer: Sniff with ubertooth, sniff the pairing, use crackle to crack it
* DOS a device
* Footprinting (stalking)
* MITM attacks (BTLE)
* Social engineer users into pairing
* MITM by cloning device. If encryption was established before, the connection will not work. The user will very liekly delete/re-pair and end up paired with the attacking device
* to break pairing: Clone device (with MAC). Now the (encrypted) connection will not work anymore. Wait for user to re-pair and sniff that. Crackle to finish

%% .. TODO: Verify list of attacks


## (Attack) Tools



### MITM on BTLE


* [btlejuice](https://github.com/DigitalSecurity/btlejuice)

%% .. TODO: Test


### Crack BTLE keys

Crackle brute force temp key
[Crackle](https://lacklustre.net/projects/crackle/)
[Crackle on Github](https://github.com/mikeryan/crackle/)

Input file must contain the complete pairing conversation.

Getting the LTK key::

{lang="bash"}
   crackle -v -i logs/c2.pcap

Decrypting the pcap::

{lang="bash"}
     crackle -v -i logs/encrypted.pcap -o logs/decrypted.pcap


### Pinging BTLE

.. TODO: Document, including DOS

### Blue Hydra

[Blue Hydra](https://github.com/pwnieexpress/blue_hydra)

### Ubertooth Utils

[Ubertooth](https://github.com/greatscottgadgets/ubertooth)


### Gattack.io

GATT: The "application" layer. While the lower layers very often do not
do encryption (pre-shared keys would be possible, but default is more likely
"none" or something weak), GATT layer could have some DIY encryption.

For the other BTLE encryption methods:

* Unencrypted: Can be broken
* "Just works": The device talks to the MITM encrypted. The MITM to the central unencrypted....broken.
* "Passkey entry" BTLE specification: “Just Works and Passkey
Entry do not provide any passive eavesdropping protection”
* Sometimes the pairing has to be broken first (also for crackle to work)

Gattacker is a node.js based MITM tool for BTLE.

[Gattack](http://gattack.io/)

[Gattacker on Github](https://github.com/securing/gattacker)
[Presentation](https://github.com/securing/docs/raw/master/slides.pdf)

The Gattacker Whitepaper has  a good overview covering BTLE
technology and the possible attacks:
[Gattacker Whitepaper](https://github.com/securing/docs/raw/master/whitepaper.pdf)

Gattack offers those attacks:

* DOS the broadcasting phase (before pairing)
* Cloning and spoofing a device
* passive interception of unencrypted transmissions
* active interception (MITM)
* module interface - attack open GATT services
* password brute forcing
* GATT value fuzzing

%% .. TODO: Check in tool of those are there

%% TODO: [Hacking BLE](https://blog.attify.com/hacking-bluetooth-low-energy/)

%% TO Add: BTLEJUICE

## BtleJack

Is a new attack on BLE

[BtleJack on Github](https://github.com/virtualabs/btlejack)

* Sniffing existing connections
* Sniffing new BLE connections
* Jamming BLE connections
* Hijacking connections
* Can export sniffed packets as PCAP

%% https://www.heise.de/security/meldung/Btlejack-Neues-Gratis-Tool-zum-Belauschen-von-Bluetooth-Verbindungen-4134142.html

## Books

There is a [list of books](#reference-collection-btle) and tools.

BTLE is a complex topic and depending on your learning style you should
either start at the *hands-on* side or at the *theoretical* side.

No matter where you start, it is very likely that you will also need some
(cheap) btle tools and products.

## Beacons

%% TODO: Write

Apple: iBeacon
Google: [Eddystone/Physical Web](http://google.github.io/physical-web/)


## Glossary

GAP: Advertisements, connection handling, defining device roles in communication
GATT: Organizes the data offered by the device
Characteristic: Value + Descriptor
Service: Several Characteristics combined create a service. A default service for BTLE would contain device information
Profile: Profiles combine several services. They standardize specific device classes
L2CAP: Encapsulating data into packets


%% TODO: [Blackhat](https://media.blackhat.com/us-13/us-13-Ryan-Bluetooth-Smart-The-Good-The-Bad-The-Ugly-and-The-Fix.pdf)


%% TODO hcidump -x -t hci0

%% TODO: [BLE security](https://www.bluetooth.com/~/media/files/specification/bluetooth-low-energy-security.ashx?la=en)

%% TODO: [BLE security basics](https://eewiki.net/display/Wireless/A+Basic+Introduction+to+BLE+Security)

%% TODO: REFERENCE: #reference-presentation-btle-sniffing


%% [BLE Capture the Flag](https://github.com/hackgnar/ble_ctf)

%% TODO: [ESP IDF](https://esp-idf.readthedocs.io/en/latest/get-started/#)
%% [ESP IDF 2](https://github.com/espressif/esp-idf)
