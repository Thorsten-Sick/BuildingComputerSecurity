# Bluetooth LE {#chapter-btle}

C> Thorsten Sick

## Basics

Bluetooth LE (low energy) is a special mode of modern bluetooth devices. It
behaves very differently fro normal bluetooth behaviour with the benefit of
significantly lower power consumption.

It does not maintain a longer connection (like used by classical bluetooth
and streaming audio) but uses small data bursts to exchange data snippets.

Those data snippets are basically key-value pairs.

A key is called a "characteristic". Several characteristics can be combined
into a service. A device can have several services. For example one handling
all the device specific data (brand, model, version) while another is sharing
measurements (temperature, air pressure, ...)

There are also "profiles" which are standardized services/characteristics for
a ble device. The "Heart Rate monitor" profile for example allows any heart
rate monitor device to be compatible with a range of apps.

A good way to get started is [Adafruit BLE](https://learn.adafruit.com/introduction-to-bluetooth-low-energy/introduction)

I am using Kali linux for many of my tests/attacks on my devices. Sometimes it
can be hard to find a bluetooth device that is working correctly
(my built-in bluetooth adapter of my laptop fails). So search your drawers for
a working device. In my case it is a LogiLink BT USB adapter BT0037. YMMV.

## Potential attacks

List of potential attacks for threat modelling:

* Jamming (smart by blocking channels or sending crafted packets, stupid by noise)
* Inpersonating (cloning) of a device
* Passive sniffing (if there is no link layer encryption)
* For encrypted layer: Sniff with ubertooth, sniff the pairing, use crackle to crack it
* DOS a device
* Footprinting (stalking)
* MITM attacks (BTLE)
* Social engineer users into pairing
* MITM by cloning device. If encryption was established before, the connection will not work. The user will very likely delete/re-pair and end up paired with the attacking device
* To break pairing: Clone device (with MAC). Now the (encrypted) connection will not work anymore. Wait for user to re-pair and sniff that. Crackle to finish

Not all of those potential attacks will be relevant for your use case. But
consider all of them in your scenario. Bluetooth is a cool technology. But
compared to a wired connection it adds complexity and increases the
attack surface.

## BLE Security

BLE securit is weaker than the Bluetooth classic security. Limiting factor is
the pairing of devices. It requires a pin number to be entered - but with small
and cheap devices without no human interaction (keypad, display) this is hard
to achieve.

* Just Works
* Numeric Comparison (Only for LE Secure Connections)
* Passkey Entry
* Out of Band (OOB)

Where the first three options have drawbacks: either an all 0 key (just works)
or short keys (all the others). The thing to go for is OOB: The pairing is
done over an other channel - not over the air. This can be NFC or QR codes or
an attached wire. Secure but not an option for many device classes.

The [bluetooth standard](https://blog.bluetooth.com/bluetooth-pairing-part-4) has more details.

Also: With Bluetooth 4.2 Elliptic Curve Diffie Hellman (ECDH) is introduced.
Try to be compatible with this version or better !

%% TODO Experiment: Can we exchange keys using bluetoothctl ?
%% [](https://github.com/IanHarvey/bluepy/issues/227)

%% Maybe bluepy gets a OOB feature: https://github.com/IanHarvey/bluepy/issues/300   (not existing yet !)

## Nordic Semiconductor: nRF Connect

The simplest tool to support you in testing a ble device you are developing is
an Android tool by Nordic Semiconductor. As you can not see radio frequencies
you have to fall back to this. Just install **nRF Connect** and scan for
devices. Connect to them, list their Services and Characteristics.

For automatic testing you will later want some other things. Just continue
reading.

## Basic OS tools

Linux has many command line tools to interact with bluetooth and bluetooth le.

Basically treat a ble device like any network device.

Activate a ble device:

{lang="bash"}
    hciconfig hci0 up

Scan for le devices:

{lang="bash"}
    hcitool lescan

Create a le connection:

{lang="bash"}
    hcitool lecc <address>

Delete a le connection:

{lang="bash"}
    hcitool ledc <handle>

Get some info like manufacturer:

{lang="bash"}
    hcitool leinfo <handle>


**gatttool** for Bluetooth LE::

%% {lang="bash"}
%%     gatttool -i <interface> -b <device address> -I
%%    > connect

%% TODO: Experiment with it !

%% to connect to a found device


## Bleah - Bluetooth LE hacking

A tool for bluetooth le hacking - and testing - is [bleah](https://github.com/evilsocket/bleah).
It can enumerate devices, list their services, list the characteristics and
write to them. This is very handy when developing Bluetooth LE enabled devices.

By [Evilsocket](https://www.evilsocket.net/)

Some examples for the command line of bleah:

Enumerate services and characteristics on a specific device

{lang="bash"}
    sudo bleah -i 1 -e -b 30:30:30:aa:aa:aa

* -i interface id. 1 is hci1
* -e enumerate
* -b <MAC> mac address of target

Set a specific value

{lang="bash"}
    sudo bleah -i 1 -b 30:30:30:aa:aa:aa -n 0x39 -d "100"

* -i interface id. 1 is hci1
* -n handle of characteristics
* -d value to set
* -b <MAC> mac address of target

Always going through bleah can be a bit slow (especially when doing fuzzing).
Gatttool can be an alternative for writing:

{lang="bash"}
    gatttool -b 30:ae:a4:1c:0c:26 --char-write-req -a 0x0039 -n $(echo -n "200"|xxd -ps)

Or reading:

{lang="bash"}
    gatttool -b 30:ae:a4:1c:0c:26 --char-read -a 0x0039

Gatttool handles values as hex, not string. Here bleah is more convenient.

Bleah is based on bluepy.

## Bluepy - python library for Bluetooth le

[Bluepy](https://github.com/IanHarvey/bluepy) is the library to use for
Bluetooth LE programming.

Thanks to a good [documentation](https://ianharvey.github.io/bluepy-doc/) it
is simple to write short python scripts to interact with your device.

## BlueZ

BlueZ is the linux kernel part (and user space tools) for Bluetooth.
Bluepy sits on top of BlueZ

## Adafruit Bluetooth LE sniffer

So far we have been checking the higher OSI layers. If you want to go down to
single packets there are two affordable options: "Adafruit Bluefruit LE Sniffer"
and the "Ubertooth".

Experimenting with the Adafruit I got challenged by some glitches
(maybe my fault, maybe the tools are better tested with the Ubertooth).

Adafruit Bluefruit LE Sniffer - Bluetooth Low Energy (BLE 4.0) - nRF51822 - v3.0
[Adafruit BLE sniffer](https://www.adafruit.com/product/2269)

[Adafruit BLE sniffer documentation](https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-sniffer)

Call it with::

{lang="bash"}
  python sniffer.py  /dev/ttyUSB0

After selecting a device it will log the BTLE messages for this device
connection into a pcap file.

To view it properly with wireshark, define the DLT_USER id to be "btle":
Preferences->Protocols->DLT_USER, set ID as "btle"

%% .. TODO: Research: Monitor connection when sending commands.

%% Wireshark does not recognize DLT_USER
%% [Ubertooth DLT fix](https://github.com/greatscottgadgets/ubertooth/issues/61)
%% go to Preferences->Protocols->DLT_USER and enter "btle" as protocol
that should help

%% .. TODO: Fill tools

## BtleJack

Is a new attack on BLE

[BtleJack on Github](https://github.com/virtualabs/btlejack)

* Sniffing existing connections
* Sniffing new BLE connections
* Jamming BLE connections
* Hijacking connections
* Can export sniffed packets as PCAP

%% https://www.heise.de/security/meldung/Btlejack-Neues-Gratis-Tool-zum-Belauschen-von-Bluetooth-Verbindungen-4134142.html

### Crackle: BTLE key cracking

For some attacks it is relevant that the bluetooth le key is cracked first.
With crackle it is possible - but requires a dump of the bluetooth packets
during the pairing process. This is the tricky part. The Adafruit sniffer or
Ubertooth can do that.

[Crackle description](https://lacklustre.net/projects/crackle/)
[Crackle on Github](https://github.com/mikeryan/crackle/)

Input file must contain the **complete** pairing conversation or it will not
work. The *tests* folder of the crackle packet has some pcaps to start
experimenting with it. Better to start with them than wasting time debuging
your tools - just because the pcap you dumped is incomplete.

Getting the LTK key::

{lang="bash"}
   crackle -v -i logs/c2.pcap

Decrypting the pcap::

{lang="bash"}
     crackle -v -i logs/encrypted.pcap -o logs/decrypted.pcap

The Adafruit sniffer seems to produce a different pcap than Ubertooth and I
had to convert my pcaps before processing with Crackle. Thanks to the internet
for help. More about how to [convert PCAP](https://github.com/mikeryan/crackle/issues/26)

## Training: BLE CTF (Capture the Flag)

There is a software for cheap ESP32 controllers to test you hacking skills
(and especially the tools listed in this chapter). It is
a [BLE Capture the Flag](https://github.com/hackgnar/ble_ctf). Just install it
as described and start testing your tools.

Hint: You will need several of the tools listed here. And maybe some simple bash
scripting or python programming.

As the ESP32 is a good eval board (with an own SDK or the Android SDK) I'll
just drop some links for this as well.

* [ESP IDF Documentation](https://esp-idf.readthedocs.io/en/latest/get-started/#)
* [ESP IDF Code](https://github.com/espressif/esp-idf)
