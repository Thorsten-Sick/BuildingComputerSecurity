# Passwords

Passwords are one of the authentication technologies used most often.

There are several kinds of passwords: Pins, Passwords and Passphrases.

## PINs

Pins are very short (4-10), contain most often only numbers and are insecure. To still
make them fly (security wise) add a delay in between pins entered (1 second).
After the 3rd wrong entry either lock the system and request a special PIN
(like PUK for a Smartphone SIM cards) or add a massive penalty (1 minute) which
increases during the next wrong entries.
A negative side effect of this is that the system can be locked by a malicious
actor...

## Passwords

Passwords are longer than PINs. As with the current state of technology
(cloud computing and GPUs) standard passwords have to be quite long to have a
decent amount of security. To improve the situation you can push the user to
create *good* passwords (heigh entropy thanks to a large character set, avoiding
the top 100 passwords, ...)

## Passphrases

Intentionally long passwords. If you create your product for a situation where
a good keyboard is available or passwords are stored in password stores you
should aim for that - or just do not artificially restrict password length and
nudge users to use long passwords in a friendly way.

## Entropy matters

Help the user to choose high-entropy passwords. Depending on the system the
user is using there are several different approaches to generate high entropy passwords.
Smartphone keyboards for example make it very difficult to enter special characters.
Maybe go for long passphrases instead ?
Also: Avoid the most common top 100 passwords (google for them). Have a list
in your app and blacklist them. Notify the user not to use those. If you have
international users you should also have international top 100 lists.

There is one exception where it is wise to use common passwords like "12345"
or "password": One time accounts without personal data attached.
Things that can be stolen without pain to the user. But as a normal user
will not be able to make this destinction - do not tell them that there is a
situation when weak passwords are ok...

High entropy is based on length of the password and potential character set
being used. This is why so many pages push people to have at least

* Lower case
* Upper case
* Special character
* A Number

In the password. As the code is simple to guarantee at least one of each is in
the password it is done that way.

One example of password entropy is the famous "Correct horse battery staple"
https://www.xkcd.com/936/


%% Troy hunt has published the top hacked passwords as Sha1. You should hash your users password and verify that it is not in the top Foo of this list before accepting it. Foo depends on your security requirements and can be a number around 1000 or better.

## Password hints

**Don't**

Users will use them and enter some easy to research data.

## Forgot password

While creating an account enforce and verify a link to a mail address.
This mail account is your "Trust Anchor" if the user forgets the password.
Create a reset link and mail the user. Make sure not to spam the user.
Do not revoke the old password until a new one is set.

Do not send a random password by mail but a (randomly generated) link to a
page you have to set a new password.

## TTL for passwords

If you force the user to renew the password regularly, store a hash of the
last 3 passwords the user used and make sure they are mnot recycled.

## Autofill trap

If you create a web page with a password form:
Do not allow autofill without user interaction on your web-page password pages.

Malicious Ads are currently creating invisible forms to steal those passwords.

https://www.theverge.com/2017/12/30/16829804/browser-password-manager-adthink-princeton-research

## Stolen passwords

Malicious actors are hacking databases and extract the passwords from there. As
users have the tendency to use the same password for different accounts this is
troubling.

The project "HaveIBEenPwned" is collecting those stolen databases from the dark
web and makes it searchable https://haveibeenpwned.com/

Hashes from there, cracked to 99% : https://hashes.org/leaks.php?id=515

Besides locking down your database server you should also "hash and salt" the
passwords you store. That way you prevent damage in case of an attack.

There are special passwords hashing algorithms that can be used.

%% TODO: Write on hash & Salt

## Cracking passwords

The technology to crack passwords is quite advanced. Besides Rainbow tables,
GPU based passwords cracking and Cloud Computing an old tool is wordlists:

%% GPU

%% Rainbow tables

### Wordlists

Attackers use Wordlists to brute force passwords. It is more effective to use
existing words and perumtate them than to generate all potential character
combinations.

Wordlists are available online

* http://www.adeptus-mechanicus.com/codex/hashpass/hashpass.php
* https://github.com/imsky/wordlists
* https://github.com/berzerk0/Probable-Wordlists

## Keyloggers

Keyloggers exist as hardware and as software variants.
Hardware variants are USB dongles attached between keyboard and computer - extern and intern.
They record keystrokes and are later collected. Some even have Wifi - reducing
the risk for the attacker. Those things are simple and can be deployed by cleaning staff.

Software keyloggers are drivers installed on the OS. Quite often by malware.
The log keys and send their data to the mothership.

One way to defeat keyloggers are on-screen keyboards. But at least for the software
keyloggers they fail. Those programs do screenshots as well as logging the physical keyboard.

So the positive effect of on-screen keyboards is limited. Please think twice if
it is the proper solution for your specific security problem or if it is just
**security theater**.

## IoT: Initial passwords

Especially IoT devices and Routers have initial passwords. Some important wisdom:

* Force the user to change that on first use
* Do never derivate it from MAC adress or other system specific number
    * No fancy maths will protect you if you do. And MAC is broadcasted on Wifi
* Do not use a increment in the factory to initialise the first password
    * Add proper Randomness instead
